# 정렬

### 정렬이란?

- `정렬(sorting)`이란 데이터를 조건에 따라`오름차순(ascending order)`이나 `내림차순(descending order)`으로 나열하는 것을 말한다.
- 입력데이터는 보통 배열과 같은 데이터 구조이며, 출력은 입력을 재배열하여 만든 순열이다.
- 정렬은 조건, 방법등에 따라서 `안정 정렬과 불안정 정렬`, `내부 정렬과 외부 정렬` 등으로 나뉘게 된다.
- 다양한 정렬 알고리즘이 있으며, 각 알고리즘은 `시간 복잡도`, `공간 복잡도`, `안정성` 등의 면에서 서로 다른 특성을 가진다.

### 정렬의 안정적 특성

- 정렬의 안정적 특성은 **정렬되지 않은 상태에서 같은 키값을 가진 원소의 순서가 정렬 후에도 유지되느냐**이다.
- 정렬을 할 때 특정 기준을 따라서 정렬을 하게 된다.
- 정렬을 할 때 꼭 `순서`를 보장하는 방식이 있고, 그렇지 않은 방식이 존재한다.
- 데이터가 `key`, `value`형태의 데이터라면 그 차이가 더욱 명확하게 보인다.

**안정 정렬(Stable Sort)**

- 안정 정렬은 정렬 후에도 그 순서가 유지된다.
  <img width="300" alt="안정 정렬" src="https://velog.velcdn.com/images%2Fhanif%2Fpost%2F41eb0f50-5b55-416b-bb8d-adae10a50d30%2Fimage.png">

**불안정 정렬(Unstable Sort)**

- 불안정 정렬은 정렬 후에 기존 순서가 유지된다는 보장을 할 수 없다.
  <img width="300" alt="불안정 정렬" src="https://velog.velcdn.com/images%2Fhanif%2Fpost%2Fe854072c-a229-410f-b5aa-de2023d203ca%2Fimage.png">

### In-place vs Not In-place

**In-place**

- 추가적인 메모리를 거의 사용하지 않고, 입력 배열이나 리스트 내에서 요소들을 직접 교환하여 정렬을 수행
- 주로 입력 데이터를 저장하고 있는 메모리 내에서 데이터를 변환하고 조작
- 공간 복잡도가 낮아 메모리 사용이 효율적이지만, 원본 데이터가 수정될 수 있어 부작용이 발생할 수 있음

**Not In-place**

- 처리 과정에서 입력 데이터의 복사본을 만들고, 추가적인 메모리를 사용하여 계산을 수행
- 원본 데이터는 유지되며, 모든 작업은 복사본이나 새로 할당된 메모리 영역에서 이루어짐
- 원본 데이터를 보존하고 알고리즘의 부작용을 방지할 수 있지만, 더 많은 메모리를 요구하고 공간 복잡도가 높다.

### 정렬의 장소

**내부 정렬(Internal Sort)**

- 정렬할 자료를 메인 메모리에 올려서 정렬하는 방식
- 정렬 속도가 빠르지만 메모리 용량의 제한을 받음

> 1.  교환 방식 : 키를 비교하고 교환하는 방식 (버블 정렬, 선택 정렬, 퀵 정렬 등)
> 2.  삽입 방식 : 키를 비교하고 삽입하는 방식 (삽입 정렬, 쉘 정렬 등)
> 3.  병합 방식 : 키를 비교하고 병합하는 방식 (2-way 병합과 같은 n-way 병합 정렬)
> 4.  분배 방식 : 여러 부분집합에 분배하여 정렬하는 방식 (기수 정렬 등)
> 5.  선택 방식 : 이진 트리를 사용하는 방식 (힙 정렬, 트리 정렬 등)

**외부 정렬(External Sort)**

- 정렬할 자료를 보조 기억장치에서 정렬하는 방식
- 대용량의 보조 기억 장치를 사용하기 때문에 내부 정렬보다 속도는 떨어지지만 대용량의 자료의 정렬 가능

> 1.  병합 방식 : 파일을 부분 파일로 분리하여 각각을 내부 정렬하고, 병합하는 방식 (2-way 병합 등의 n-way 병합 정렬)

### 정렬 알고리즘의 종류

**1. 버블 정렬(Bubble Sort)**

- 서로 인접한 두 원소의 대소를 비교하여 조건에 맞지 않다면 자리를 교환하며 정렬하는 알고리즘

<img width="300" alt="버블 정렬" src="https://blog.kakaocdn.net/dn/nsZ8p/btrAIf9uNf6/oMrfjknBSpMQPEkUQgNZ71/img.gif">

**과정**

1. 첫번째 수와 두 번째 수를 비교해서 큰 수가 오른쪽에 위치하게 교체한다.
2. 두 번째 수와 세 번째 수를 비교해서 큰 수가 오른쪽에 위치하게 교체한다.
3. 가장 오른쪽에 도달할 때까지 1,2번을 반복한다.
4. 오른쪽 끝에 최대값이 도달하였음으로 이 수를 제외하고 나머지 수에 대해서 수가 1개가 남을 때까지 1~3번 과정을 반복한다.

**장점**

> - 구현이 매우 간단하고, 소스코드가 직관적이다.
> - 정렬하고자 하는 배열 안에서 교환하는 방식이므로 In-place 정렬이다.
> - Stable 정렬이다.

**단점**

> - 데이터를 하나씩 비교하기 때문에 비교 횟수가 많아지므로 시간이 오래 걸리기 때문에, 시간 복잡도가 최악, 최선, 평균 모두 O(n^2)으로, 굉장히 비효율적이다.
> - 정렬된 상태에서 새로운 데이터가 추가되면 정렬 효율이 좋지않다.

**2. 선택 정렬(Selection Sort)**

- 해당 순서에 원소를 넣을 위치는 이미 정해져 있고, 어떤 원소를 넣을지 선택하는 알고리즘

<img width="300" alt="선택 정렬" src="https://blog.kakaocdn.net/dn/cqCvsg/btrAVs0WT4A/zuxAMlsX5t758nSa6MwvK1/img.gif">

**과정**

1. 주어진 배열에서 최솟값을 찾는다.
2. 그 최솟값과 맨 앞에 위치한 값을 교체한다.(swap)
3. 맨 앞에 위치한 값을 제외한 나머지 배열에 대해서 같은 방법으로 교체한다.

**장점**

> - 버블 정렬과 마찬가지로 구현이 간단하다.
> - 비교하는 횟수에 비해 교환하는 횟수가 적기 때문에, 많은 교환이 일어나야 하는 자료 상태에서 비교적 효율적이다.
> - 정렬하고자 하는 배열 안에서 교환하는 방식이므로 In-place 정렬이다.

**단점**

> - 데이터를 하나씩 비교하기 때문에 시간복잡도가 O(n^2)으로, 비효율적이다.
> - Unstable 정렬이다. (구현하는 방식에 따라 달라질 수 있음)
> - 정렬된 상태에서 새로운 데이터가 추가되면 정렬 효율이 좋지 않다.

**3. 삽입 정렬(Insertion Sort)**

- 선택 정렬과 유사하지만, 좀 더 효율적인 정렬 알고리즘
- 2번째 원소부터 시작하여 그 앞(왼쪽)의 원소들과 비교하여 삽입할 위치를 지정한 후, 원소를 뒤로 옮기고 지정된 자리에 자료를 삽입 하여 정렬하는 알고리즘

<img width="300" alt="삽입 정렬" src="https://blog.kakaocdn.net/dn/rGBXh/btrASwpIeko/TLrkTXTvJwRQvp7QOzhC2K/img.gif">

**과정**

1. 첫 번째에 위치한 수(인덱스 0번 위치의 수)는 이미 정렬이 완료되었다고 가정한다.
2. 정렬 리스트의 오른쪽에 있는 정렬되지 않은 수(인덱스 1번 위치의 수)는 자신의 앞에 있는 수와 크기를 비교하여 앞쪽 수가 더 크면 자리를 바꾼다.
3. 인덱스 2번 위치의 수도 왼쪽으로 전진 하면서 자기 자리를 찾는다.
4. 더 이상 정렬된 대상 원소가 없을 때까지 반복한다.

**장점**

> - 입력으로 들어오는 배열의 원소가 정렬되어있을수록 속도가 빠르다.
> - 정렬된 값은 교환이 일어나지 않기 때문에, 이미 정렬되어 있는 배열에 자료를 하나씩 삽입/제거하는 경우에는 현실적으로 최고의 정렬 알고리즘이 된다.
> - 정렬하고자 하는 배열 안에서 교환하는 방식이므로 In-place 정렬이다.
> - Stable 정렬이다.
> - 선택 정렬, 버블 정렬과 같은 O(n^2) 알고리즘에 비교하여 상대적으로 빠르다.

**단점**

> - 평균과 최악의 시간복잡도가 O(n^2)으로 비효율적이다.
> - 선택 정렬, 버블 정렬과 마찬가지로 배열의 길이가 길어질수록 비효율적이다.

**4. 퀵 정렬(Quick Sort)**

- 분할정복 방식으로 고안된 정렬방법으로 먼저 임의의 기준을 선택하여 그 기준보다 작은 값은 왼쪽에, 큰 값을 오른쪽에 위치시킨 후 다시 임의의 기준을 선택하여 왼쪽과 오른쪽을 반복하여 나누어 가며 정렬하는 방법
- 재귀호출을 사용

> 분할정복
>
> - 큰 문제를 작은 문제 단위로 쪼개면서 해결해 나가는 방식

<img width="300" alt="퀵 정렬" src="https://blog.kakaocdn.net/dn/dIqOwt/btrAVtyN6CV/LFxg1TL5OrdcWAuwMInIzk/img.gif">

**과정**

1. 왼쪽과 오른쪽에 해당하는 원소들에 대해 두 배열로 나눈다. -> 분할(Divide)
2. 분할된 두 개의 작은 배열에 대해 재귀(Recursion)적으로 이 과정을 반복한다.
3. 재귀 호출이 한번 진행될 때마다 최소한 하나의 원소는 최종적으로 위치가 정해지므로, 이 알고리즘은 반드시 끝난다는 것을 보장할 수 있다.

**장점**

> - 불필요한 데이터의 이동을 줄이고 먼 거리의 데이터를 교환한다.
> - 한 번 결정된 pivot들이 추후 연산에서 제외되는 특성 때문에, 시간 복잡도 O(nlogn)을 가지는 다른 정렬 알고리즘과 비교했을 때 가장 빠르다.
> - 정렬하고자 하는 배열 안에서 교환하는 방식이므로 In-place 정렬이다.

**단점**

> - 정렬된 배열에 대해서는 불균형 분할에 의해 오히려 수행시간이 더 많이 걸린다.
> - Unstable 정렬이다.

**5. 병합 정렬(Merge Sort)**

- 정렬할 배열을 반으로 나누어 좌측과 우측 배열을 계속하여 분할해 나간 후 각 배열내에서 정렬 후 병합하는 과정을 통해 정렬하는 알고리즘

> 분할정복
>
> - 큰 문제를 작은 문제 단위로 쪼개면서 해결해 나가는 방식

<img width="300" alt="병합 정렬" src="https://blog.kakaocdn.net/dn/bpXxX7/btrBzUvXZOf/RCAxQSEte1x8DmwbZaRLO0/img.gif">

**과정**

1. 분할: 배열을 같은 크기의 2개의 부분 배열로 분할한다.
2. 정복: 부분 배열을 정렬한다.
3. 결합: 정렬된 부분 배열들을 하나의 배열에 병합한다.
   > 1. 2개의 리스트의 값들을 처음부터 하나씩 비교하여 더 작은 값을 새로운 리스트로 옮긴다.
   > 2. 둘 중 하나가 끝날 때까지 반복한다.
   > 3. 둘 중 하나가 먼저 끝나면 나머지 리스트의 값들을 전부 넣는다.
   > 4. 새로운 리스트를 원래 리스트로 옮긴다.

**장점**

> - 항상 일정한 시간 복잡도 O(nlogn)를 가진다.
> - Stable 정렬이다.

**단점**

> - 정렬을 하는 배열외의 추가적인 임시 배열 (추가적인 메모리)가 필요하다.
> - 정렬하고자 하는 배열의 크기만큼의 추가적인 크기가 요구되기 때문에 Not In-place 정렬이다.

**6. 힙 정렬(Heap Sort)**

- 합을 이용한 정렬 방법

> 힙(Heap)
>
> - 힙(Heap)은 최대값 또는 최소값을 빠르게 찾기 위해 고안된 완전이진트리를 기본으로한 자료구조
> - 완전이진트리는 삽입할 때 왼쪽부터 차례대로 추가하는 이진트리다.
> - 힙(Heap)의 종류로 최대힙과 최소힙이 있다.
> - 최대힙이라면 부모노드의 키값이 자식노드의 키값보다 크다는 특징이 있다.
> - 최소힙이라면 부모노드의 키값이 자식노드의 키값보다 작다는 특징이 있다.

<img width="300" alt="힙 정렬" src="https://blog.kakaocdn.net/dn/b99Tq3/btrBzdWOH3Q/eUl45KKk06dKtYO19HWnbk/img.gif">

**과정**

<img width="300" alt="힙 정렬" src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FkzgWe%2FbtrBzdW6bBU%2FxqWvAqINgknhC9fwub55F1%2Fimg.png">

1. 힙 트리를 구성한다. (내림차순으로 정렬하기 위해서는 최대 힙 트리를 구성하고 오름차순으로 구성하기 위해서는 최소 힙 트리를 구성한다.)
2. 루트를 힙의 마지막 원소와 교환한다.
3. 마지막 원소를 제외하고 나머지 원소에 대해서 반복한다.
4. 정렬된 원소를 제외하고 최대 힙에 원소가 1개 남으면 정렬을 종료한다.

**장점**

> - 가장 크거나 가장 작은 값을 구할 때 유용하다. → 한번의 힙 구성을 통해 구하는 것이 가능하다.
> - 멀리 떨어진 요소들을 정렬할 때 유용하다 → 삽입정렬보다 더욱 개선된 결과를 얻어낼 수 있다.
> - 항상 같은 시간 복잡도를 가지기 때문에 성능이 준수하다.
> - 주어진 배열 내부에서 위치를 바꾸는 방식으로 하면 In-place 정렬이 가능하다.

**단점**

> - 같은 시간 복잡도를 가지는 다른 정렬 알고리즘과 비교하면 느린 편이다.
> - Unstable 정렬이다.

**7. 계수 정렬(Counting Sort)**

- 숫자들간 비교를 하지 않고 정렬을 하는 알고리즘
- 각 숫자가 몇개 있는지 개수를 세어 저장한 후에 정렬하는 방식

<img width="300" alt="계수 정렬" src="https://blog.kakaocdn.net/dn/vurcx/btqFPrXv8rg/kFWVlJLIPZNzvVaFRZ7G51/img.gif">

**과정**

1. 정렬하고자 하는 배열의 최대값을 구한다.
2. 최대값 크기의 배열에 각 원소를 순회하며 해당 값이 몇개인지 저장한다.
3. 저장된 데이터를 순서대로 출력한다.

**장점**

> - 정렬하는 숫자가 특정한 범위 내에 있을 때 유용하다.
> - 비교없는 O(n) 의 시간복잡도를 가진다.
> - 맨 뒤의 수부터 값을 채우기 때문 Stable 정렬이다.

**단점**

> - 입력 데이터의 최대값에 따라 카운팅 배열의 크기가 커져서 메모리 낭비가 심하다.
> - Not In-place 정렬아다.

**8. 기수 정렬(Radix sort)**

- 낮은 자리수부터 비교하여 정렬해 간다는 것을 기본 개념으로 하는 정렬 알고리즘
- 기수 정렬은 비교 연산을 하지 않으며 정렬 속도가 빠르지만 데이터 전체 크기에 기수 테이블의 크기만한 메모리가 더 필요

<img width="300" alt="기수 정렬" src="https://blog.kakaocdn.net/dn/DWH0S/btqFOYnIbCu/Q7HOAOzzvlD4xW279LqTLK/img.gif">

**과정**

1. 데이터 중 가장 큰 자리수를 구한다.
2. 가장 작은 자리수부터 가장 큰 자리수까지 해당 자리수만을 보고 Conting Sort를 진행힌다.

**장점**

> - 비교없는 O(n) 의 시간복잡도를 가진다.
> - 문자열, 정수 정렬 가능하다. (음수가 있을 경우에는 음수를 따로 빼내서 똑같은 방법으로 정렬 한 후, 결과를 양수 결과랑 합치는 식으로 해야 한다.)
> - Stable 정렬이다.

**딘점**

> - 자릿수가 없는 것은 정렬할 수 없다. (부동 소수점)
> - 중간 결과를 저장할 bucket 공간이 필요하다.
> - Not In-place 정렬이다.
