# 스택 & 큐

## 스택(Stack)

### 스택(Stack)이란?

- 실행이 되는 특정한 순서를 따르는 선형적 데이터 구조이다.
- 책을 쌓는 것처럼 차곡차곡 쌓아 올린 형태의 자료구조이다.

### 스택의 특징

- 가장 마지막에 삽입된 데이터가 가장 먼저 삭제되는 특징으로 스택은 시간 순서에 따라 데이터가 쌓인다.
- 스택은 가장 늦게 들어온 데이터가 가장 먼저 나가는 LIFO(Last In First Out)형태의 자료구조이다.
- 데이터 한 쪽 에서만 자료를 넣고 뺄 수 있다.

> 1. LIFO(Last in First Out) : 마지막에 들어온 데이터가 먼저 나가는 데이터 구조
> 2. FILO(First in Last Out) : 처음 들어온 데이터가 마지막에 나가는 데이터 구조

<img width="300" alt="스택" src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2F70Ehc%2Fbtsc1O7ftVg%2FIMSS4Vdv4bN3PbekEDKoz0%2Fimg.png">

### 메서드

**1. push()**

- push()연산은 스택에 데이터를 push, 즉 삽입하는 연산이다.
- 현재 스택의 가장 최근의 들어온 데이터(가장 상단에 위치한 데이터)를 top이 가리키게 된다.
  push 연산을 하게 될 경우 현재 top이 가리키는 데이터 위에 데이터를 추가한 뒤, 추가된 데이터를 top이 가리킨다.

**2. pop()**

- pop() 연산은 스택에 데이터를 pop, 즉 꺼내는 연산이다.
- 현재 스택에서 top이 가리키고 있는 데이터를 꺼낸 후, 현재 스택에서 최상단에 위치한 데이터를 top이 가리키게 된다.
- 만일 꺼낼 데이터가 없을 경우에는 pop 연산이 실행되지 않는다.

**3. peek()**

- peek() 연산은 현재 top이 가리키고 있는 데이터를 확인하는 연산이다.
- 이때 pop()과의 다른 점이라면, pop연산은 데이터를 stack에서 꺼내서 읽는다면 peek 연산은 데이터를 꺼내지 않고 값만 읽는 것이다.

**4. isEmpty()**

- isEmpty() 연산은 현재 stack이 비어있는지 확인하는 연산이다.
- stack이 비어있다면 true, 비어있지 않다면 false를 반환한다.

### 장단점

**장점**

> - 데이터의 삽입과 삭제가 빠르다.
> - 구현이 쉽다.

**단점**

> - 맨 위의 원소만 접근 가능하다.
> - 탐색을 하려면 원소를 하나하나 꺼내서 옮겨가면서 해야한다.

### 스택의 사용

- 재귀 알고리즘
- 역순 문자열 만들기
- 시스템 스택
- 웹 브라우저 방문기록 (뒤로 가기)
- 실행 취소 (undo)
- 후위 표기법 계산
- 수식의 괄호 검사

## 큐(Queue)

### 큐(Queue)란?

- 큐(Queue)는 먼저 들어온게 먼저 나가는 선입선출방식이다.
- 큐는 스택과 같은 선형적 구조이다.

### 큐의 특징

- 큐는 먼저 들어온 것이 먼저 나가는 FIFO(First In First Out) 방식의 자료구조이다.
- 큐의 한 쪽 끝(Rear)에서는 데이터 삽입만 가능하며, 다른 한 쪽 끝(Front)에서는 데이터 삭제만 가능하다.
- 큐에서 데이터가 추가되는 것을 Enqueue, 데이터가 삭제되는 것을 Dequeue라고 한다.

<img width="300" alt="큐" src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbvSYuo%2FbtscY4pXnhy%2FKVaZDLK6JbgNsFTdXQMpx1%2Fimg.png">

### 메서드

**1. add()**

- add() 연산은 큐에 데이터를 추가하는 연산이다.
- 큐에 데이터를 추가하면 Rear의 값이 1이 증가된다.
- 만일 큐가 꽉 차게 된다면 더 이상 삽입할 수 없다.

**2. remove()**

- remove() 연산은 큐에서 데이터를 제거하는 연산이다.
- 큐에서 front가 가리키는 데이터를 삭제한 뒤, front의 값을 1 증가시킨다.
- 만일 rear와 front의 위치가 동일하다면, 이는 큐에 남은 데이터가 없음을 의미하고 더이상 삭제할 수 없다.

**3. peek()**

- peek() 연산은 큐에서 가장 앞에 있는 데이터(가장 오래전에 삽입 된 데이터)를 확인하는 연산이다.
- peek() 연산과 remove() 연산의 차이점은 remove() 연산은 데이터를 삭제한 후 읽는다면, peek() 연산은 데이터를 삭제하지 않고 확인할 수 있다.

**4. isEmpty()**

- isEmpty() 연산은 큐가 비어있는지 확인해주는 연산이다.
- 반환 타입은 boolean으로 큐가 비어있다면 true, 비어있지 않다면 false를 반환한다.

### 장단점

**장점**

> - 데이터의 삽입 삭제가 빠르다.
> - 순차적으로 되어 있어서 입력 순서에 따라 처리할 때 유용하다.

**단점**

> - 중간에 위치한 데이터에 접근하기 어렵다.
> - 배열로 구현하면 삽입, 삭제에 한계가 존재한다.(이 문제를 해결하고자 나온 것이 바로 원형 큐이다.)

### 큐의 사용

- 데이터가 입력된 순서에 따라 처리되어야 할 때 사용
- 프린터와 같은 우선순위 작업 예약
- 은행 업무
- 콜센터 고객 대기시간
- 프로세스 관리
- 너비 우선 탐색(BFS, Breadth-First Search) 구현
- 캐시(Cache) 구현

### 큐의 종류

**1. 원형 큐(Circular Queue)**

- 선형 큐(Queue)는, 이미 사용한 영역인 front의 앞부분에 대해서 다시 활용을 못하기 때문에 메모리를 낭비한다는 단점이 있었다.
- 그리고 큐가 다 찼을 경우 데이터들을 앞쪽으로 이동시켜 사용하는 방법이 있지만 남아있는 모든 데이터를 다 이동시켜야 한다는 불편한 작업을 수행해야 하기 때문에 그리 효율적으로 동작하지 못한다.
- 이런 문제를 해결하고자 나온 큐가 바로 원형 큐이다.
- 큐의 형태가 원형으로 되어 있어 원형 큐라고 한다.
- 원형 큐는 처음과 끝이 연결되어 있는 형태로, 데이터가 배열의 끝에 다다르면 다시 처음으로 돌아올 수 있어 이미 사용했던 부분도 재사용이 가능하다.

<img width="300" alt="원형 큐" src="https://user-images.githubusercontent.com/52641909/111613749-3090e580-8822-11eb-9c9b-b53a674614fb.png">

**장점**

- 선형큐와 비교하였을 때, 메모리 낭비가 발생하지 않는다.

**단점**

- 똑같은 배열이기에 크기가 정해져있다.

**2. 우선순위 큐(Priority Queue)**

- 우선순위 큐는 들어간 순서에 상관없이 데이터의 우선순위에 따라서 우선순위가 높은 데이터부터 꺼내도록 만들어진 큐이다.
- 내부 요소는 힙으로 구성된 이진트리 형태이다.
- 우선순위 큐는 배열과 연결리스트, 힙으로 구현을 할 수 있다.
- 배열로 구현을 할 경우 삽입 삭제는 빠르지만, 나머지 인덱스를 한 칸씩 연산을 할 때마다 옮겨줘야 하기 때문에 번거롭다.
- 연결리스트로 구현할 경우 처음부터 끝까지 우선순위를 탐색해야 할 수도 있는데, 이는 큐의 성능을 크게 저하시킨다.
