# 해시 알고리즘과 해시 테이블

## 해시 알고리즘
- 어떤 데이터를 고유하고 고정된 크기의 해시 값으로 변환하는 프로세스
- 이 해시 값은 입력 데이터의 양과 관계없이 항상 일정한 크기를 가짐
- 데이터의 무결성 검증하거나 배열의 인덱스, 위치, 데이터 값 등 효율적인 데이터 저장과 검색

## 해시 테이블
- 해시 알고리즘을 사용하여 key-value 쌍으로 된데이터를 저장하고 관리하는 데이터 구조
- 정보를 저장하고 찾을 때 해시 알고리즘을 사용하는 목록
- 해시 함수를 사용하여 각 키를 테이블의 인덱스로 변환하여 데이터에 빠르게 접근

### Object 객체
- 자바스크립트에서 가장 기본적인 형태의 해시테이블
- 키는 문자열 또는 심볼로 제한
- 프로토타입 체인 때문에 Object.prototype을 상속받아 몇몇 기본 키를 가지고 있어, 예상치 못한 키 충돌의 가능성
- 내장 메서드와 속성이 있어, 순수한 해시테이블로 사용하는 데 한계
- 간단한 키-값 쌍을 저장하거나, 프로토타입 체인의 이점을 활용할 때 적합

```
let obj = {
  key1: 'value1',
  key2: 'value2'
};

console.log(obj.key1); // 'value1'
obj.key3 = 'value3';
console.log(obj); // { key1: 'value1', key2: 'value2', key3: 'value3' }
```

### Map 객체
- ES6에서 도입된 키-값 쌍을 저장하기 위한 더 정교한 구조
- 키는 어떤 타입이든 될 수 있으며, 객체를 키로 사용 가능
- 키-값 쌍의 삽입 순서가 유지
- size 속성, set(), get(), has(), delete(), clear() 등의 유용한 메서드를 제공
- 데이터가 자주 추가되거나 삭제되고, 키가 다양한 데이터 타입을 가질 때 유용

```
let map = new Map();
map.set('key1', 'value1');
map.set('key2', 'value2');

console.log(map.get('key1')); // 'value1'
console.log(map.size); // 2
map.delete('key2');
console.log(map.has('key2')); // false
```

###  해시 테이블의 주요 용도 및 특징
1. **데이터 저장 및 검색**\
    평균적으로 O(1)의 시간 복잡도를 가지며, 이는 데이터 저장 및 검색이 매우 빠르다는 것을 의미

2. **고유성 보장**\
    해시테이블의 각 키는 고유해서 데이터의 중복을 방지하고, 데이터의 무결성을 유지하는 데 중요한 역할
    
3. **동적 크기 조정**\
    데이터의 양이 변함에 따라 해시테이블의 크기가 동적으로 조정되어 메모리 사용의 효율성 증가

### 예시: 카페 메뉴의 배열과 해시 테이블 비교

```
// 배열로 저장된 카페 메뉴
let menu = [
  {name: "아메리카노", price: 10},
  {name: "라떼", price: 13},
  {name: "밀크티", price: 15},
  {name: "유자차", price: 14},
];

// 해시 테이블로 저장된 카페 메뉴
let menu_hash = {
    "아메리카노": 10,
    "라떼": 13,
    "밀크티": 15,
    "유자차": 14,
};
```
해시 테이블을 사용하면 '밀크티'의 가격을 배열에서 일일이 검색하지 않고도 빠르게 찾을 수 있습니다.

## 해시 함수
- 해시 테이블 내에서 특정 키를 인덱스로 변환하는 데 사용되는 구체적인 함수
- 데이터를 해시 테이블의 버킷에 효율적으로 분산시킴
- 좋은 해시 함수는 충돌을 최소화하고, 해시 테이블의 공간을 균일하게 사용

### 해시 함수 특징
- 동일한 입력에 대해 항상 동일한 해시 값을 반환
- 매우 빠른 속도로 해시 값을 계산해야 함
- 해시 테이블의 버킷에 데이터를 균일하게 분포시켜야 함

### 해시 함수 예시
```
function simpleHash(key) {
    let hash = 0;
    for (let i = 0; i < key.length; i++) {
        hash += key.charCodeAt(i);
    }
    return hash;
}
```

### 해시 함수 중요성
- 해시 테이블의 성능은 대부분 사용되는 해시 함수의 효율성에 의해 결정
- 효과적인 해시 함수는 해시 테이블 내의 데이터 충돌을 최소화하며, 빠른 데이터 접근을 가능하게 함

## 해시 충돌
해시 테이블에서는 서로 다른 키가 동일한 해시 값을 가질 때, 두 데이터가 같은 위치에 저장되려고 시도하는 충돌이 발생할 수 있습니다. 이를 해결하기 위한 방법으로 체이닝, 개방 주소법 등의 기술이 사용됩니다.

### 해시 충돌의 종류
- **동일 해시 충돌**:\
두 개의 서로 다른 입력 값이 동일한 해시 값을 생성하는 경우

- **버킷 충돌**:\
다른 해시 값이 같은 버킷(또는 슬롯)에 할당되는 경우\
  ※ **버킷**: 해시 테이블에서 데이터를 저장하는 기본 단위로, 키-값 쌍을 저장하는 '슬롯' 또는 '자리'

### 해시 충돌 해결 방법

- **체이닝(Chaining)**
  -  각 해시 버킷에 연결 리스트를 사용하여 여러 개의 키-값 쌍을 저장
  - 구현이 비교적 간단하지만, 많은 데이터가 하나의 버킷에 집중되면 검색 시간이 길어질 가능성

- **개방 주소법(Open Addressing)**
  - 충돌이 발생하면, 다른 버킷에 데이터를 저장
  -  데이터가 테이블 전체에 고르게 분포되지만, 테이블이 가득 차면 성능 저하 가능성
